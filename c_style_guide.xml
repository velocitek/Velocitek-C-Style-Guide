<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="styleguide.xsl"?>
<GUIDE title="Velocitek C Style Guide">

<p align="right">

Revision 0.1
</p>


<address>
Alec Stewart<br/>

</address>

<OVERVIEW>
<CATEGORY title="Important Note">
  <STYLEPOINT title="Displaying Hidden Details in this Guide">
     <SUMMARY>
       This style guide contains many details that are initially
       hidden from view.  They are marked by the triangle icon, which you
       see here on your left.  Click it now.
       You should see "Hooray" appear below.
     </SUMMARY>
     <BODY>
       <p>
        Hooray!  Now you know you can expand points to get more
        details.  Alternatively, there's an "expand all" at the
        top of this document.
       </p>
     </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="Background">
  <p>
    C is the language used for Velocitek firmware.
  </p>
  <p>
    The goal of this guide is to describe a consistent set of conventions for writing C that
    Velocitek's developers can follow to make our source code more readable and easier to maintain.     
  </p>
  <p>
    This guide is mostly a copy of the 
    <a HREF="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++ Style Guide</a>. Parts that are only relevant to C++ have been removed and a few Velocitek-specific additions have been made. The most substantial deviation from the Google C++ Style Guide is in indenting style; this guide specifies Allman style, where opening curly braces get a new line. The Google style puts an opening brace on the same line as the corresponding function declaration or loop statement.
  </p>
  
  <p>
    <em>Style</em>, also known as readability, is what we call the
    conventions that govern our C code. The term Style is a bit of a
    misnomer, since these conventions cover far more than just source
    file formatting.
  </p>
  <p>
    One way in which we keep the code base manageable is by enforcing
    <em>consistency</em>. It is very important that any programmer be able 
    to look at another's code and quickly understand it.
    Maintaining a uniform style and following conventions means that we can
    more easily use "pattern-matching" to infer what various symbols are
    and what invariants are true about them. Creating common, required
    idioms and patterns makes code much easier to understand.  In some
    cases there might be good arguments for changing certain style
    rules, but we nonetheless keep things as they are in order to
    preserve consistency.
  </p>
  <p>
    Another issue this guide addresses is that of C feature bloat. In some cases
    we constrain, or even ban, use of certain features. We do this to
    keep code simple and to avoid the various common errors and
    problems that these features can cause.  This guide lists these
    features and explains why their use is restricted.
  </p>
    
  <p>
    Note that this guide is not a C tutorial: we assume that the
    reader is familiar with the language.
    
  </p>
  
</CATEGORY>
</OVERVIEW>

<CATEGORY title="Header Files">
  <p>
    In general, every <code>.c</code> file should have an associated
    <code>.h</code> file. There are some common exceptions, such as
    
    unittests
    and small <code>.c</code> files containing just a <code>main()</code>
    function.
  </p>
  <p>
    Correct use of header files can make a huge difference to the
    readability, size and performance of your code.
  </p>
  <p>
    The following rules will guide you through the various pitfalls of
    using header files.
  </p>

<STYLEPOINT title="Use of #pragma once">
  <SUMMARY>
    All header files should begin with <code>#pragma once</code> to prevent multiple inclusion.
  </SUMMARY>
  <BODY>

    <p>
      Instead of traditional <code>#define</code> guards, use <code>#pragma once</code> at the top of each header file. This is widely supported by modern compilers and avoids issues with guard name collisions and maintenance.
    </p>

    <p>
      For example, the file <code>foo/src/bar/baz.h</code> in project <code>foo</code> should start with:
    </p>
    <CODE_SNIPPET>
       #pragma once

       ...
    </CODE_SNIPPET>

    <p>
      This approach simplifies the code and is less error-prone than manually maintaining <code>#ifndef</code> include guards.
    </p>

  </BODY>
</STYLEPOINT>

  <STYLEPOINT title="Inline Functions">
    <SUMMARY>
      Define functions inline only when they are small, say, 10 lines
      or less.
    </SUMMARY>
    <BODY>
      <DEFINITION>
        You can declare functions in a way that allows the compiler to
        expand them inline rather than calling them through the usual
        function call mechanism.
      </DEFINITION>
      <PROS>
        Inlining a function can generate more efficient object code,
        as long as the inlined function is small. Feel free to inline
        accessors and mutators, and other short, performance-critical
        functions.
      </PROS>
      <CONS>
        Overuse of inlining can actually make programs slower.
        Depending on a function's size, inlining it can cause the code
        size to increase or decrease.  Inlining a very small accessor
        function will usually decrease code size while inlining a very
        large function can dramatically increase code size.  On modern
        processors smaller code usually runs faster due to better use
        of the instruction cache.
      </CONS>
      <DECISION>
        <p>
          A decent rule of thumb is to not inline a function if it is
          more than 10 lines long. Beware of destructors, which are
          often longer than they appear because of implicit member-
          and base-destructor calls!
        </p>
        <p>
          Another useful rule of thumb: it's typically not cost
          effective to inline functions with loops or switch
          statements (unless, in the common case, the loop or switch
          statement is never executed).
        </p>
        <p>
          It is important to know that functions are not always
          inlined even if they are declared as such; for example,
          virtual and recursive functions are not normally inlined.
          Usually recursive functions should not be inline. 
        </p>
      </DECISION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="The -inl.h Files">
    <SUMMARY>
      You may use file names with a <code>-inl.h</code> suffix to define
      complex inline functions when needed.
    </SUMMARY>
    <BODY>
      <p>
        The definition of an inline function needs to be in a header
        file, so that the compiler has the definition available for
        inlining at the call sites.  However, implementation code
        properly belongs in <code>.cc</code> files, and we do not like
        to have much actual code in <code>.h</code> files unless there
        is a readability or performance advantage.
      </p>
      <p>
        If an inline function definition is short, with very little,
        if any, logic in it, you should put the code in your
        <code>.h</code> file.  For example, accessors and mutators
        should certainly be inside a class definition.  More complex
        inline functions may also be put in a <code>.h</code> file for
        the convenience of the implementer and callers, though if this
        makes the <code>.h</code> file too unwieldy you can instead
        put that code in a separate <code>-inl.h</code> file.
        This separates the implementation from the class definition,
        while still allowing the implementation to be included where
        necessary.
      </p>
      <p>
        Another use of <code>-inl.h</code> files is for definitions of
        function templates.  This can be used to keep your template
        definitions easy to read.
      </p>
      <p>
        Do not forget that a <code>-inl.h</code> file requires a
        <a href="#The__define_Guard"><code>#define</code> guard</a> just
        like any other header file.
      </p>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Parameter Ordering">
    <SUMMARY>
      When defining a function, parameter order is: inputs,
      then outputs.
    </SUMMARY>
    <BODY>
      <p>
        Parameters to C functions are either input to the
        function, output from the function, or both. Input parameters
        are usually values or <code>const</code> references, while output
        and input/output parameters will be non-<code>const</code>
        pointers. When ordering function parameters, put all input-only
        parameters before any output parameters.  In particular, do not add
        new parameters to the end of the function just because they are
        new; place new input-only parameters before the output
        parameters.
      </p>
      <p>
        This is not a hard-and-fast rule.  Parameters that are both
        input and output (often structs) muddy the waters,
        and, as always, consistency with related functions may require
        you to bend the rule.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Names and Order of Includes">
    <SUMMARY>
      Use this order for readability and to avoid hidden
      dependencies: 
      
      <ul>
          <li> Main <code>.h</code> file that contains MCU fuse settings,
               clock settings, and stream definitions.
               </li>
          <li> Standard C libraries
               </li>
          <li> Other libraries
               </li>
          <li> Your project's <code>.h</code> files
               </li>
                    
        </ul>
      
    </SUMMARY>
    <BODY>
      <p>
        
        All of a project's header files should be
        listed as descendants of the project's source directory
        without use of UNIX directory shortcuts <code>.</code> (the current
        directory) or <code>..</code> (the parent directory).  For
        example,
        
        <code>velocitek-awesome-project/src/base/logging.h</code>
        should be included as
      </p>
      <CODE_SNIPPET>
        #include "base/logging.h"
      </CODE_SNIPPET>
      
      <p>
        Within each section the includes should be ordered alphabetically.
        Note that older code might not conform to this rule and should be
        fixed when convenient.
      </p>
    
      <p>
        Exception: sometimes, system-specific code needs conditional includes.
        Such code can put conditional includes after other includes.
        Of course, keep your system-specific code small and localized.
        
      </p>
      
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Scoping">


  <STYLEPOINT title="Private Functions">
    <SUMMARY>
      Always put the static keyword in front of both the prototype and the definition of any functions that are only used in a single module to limit their scope to that module.
    </SUMMARY>
    
  </STYLEPOINT>

  <STYLEPOINT title="Local Variables">
    <SUMMARY>
      Place a function's variables in the narrowest scope possible, while maintaining compliance with  ANSI C (C89) which limits you to declaring variables just after an opening brace.
    </SUMMARY>
    <BODY>
      <p>
        We encourage you to declare them in as local a scope as possible, and as close to the first use as possible. This makes it easier for the reader to find the declaration and see what type the variable is and what it was initialized to. In particular, initialization should be used instead of declaration and assignment, e.g.
      </p>
      <BAD_CODE_SNIPPET>
        int i;
        i = f();      // Bad -- initialization separate from declaration.
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        int j = g();  // Good -- declaration has initialization.
      </CODE_SNIPPET>
      
      
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Global and Module Variables">
    <SUMMARY>
      <p>
        To help with encapsulation, variables with global scope are forbidden unless they are <code>const</code>. 
      </p>      
      <p>
        Always use the static keyword with any variable declaration that happens outside a function definition. This limits the scope of the variable to the module that the declaration appears in.
      </p>      
      <p>
        If you need to access a module-level variable from another module, write public get and/or set functions for the variable.
      </p>
    </SUMMARY>
    
    <BODY>
            
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Other C Features">

  <STYLEPOINT title="Use of const">
    <SUMMARY>
      Use <code>const</code> whenever it makes sense.
      
    </SUMMARY>
    <BODY>
      <DEFINITION>
        Declared variables and parameters can be preceded by the
        keyword <code>const</code> to indicate the variables are not
        changed (e.g., <code>const int foo</code>).
      </DEFINITION>
      <PROS>
        Easier for people to understand how variables are being used.
        Allows the compiler to do better type checking, and,
        conceivably, generate better code.  Helps people convince
        themselves of program correctness because they know the
        functions they call are limited in how they can modify your
        variables.  
      </PROS>
      <CONS>
        <code>const</code> is viral: if you pass a <code>const</code>
        variable to a function, that function must have <code>const</code>
        in its prototype (or the variable will need to be cast to a non-<code>const</code> type). This can be a particular problem
        when calling library functions.
      </CONS>
      <DECISION>
        <p>
          <code>const</code> variables, data members, methods and
          arguments add a level of compile-time type checking; it
          is better to detect errors as soon as possible.
          Therefore we strongly recommend that you use
          <code>const</code> whenever it makes sense to do so.
        </p>
        
      </DECISION>
      <SUBSECTION title="Where to put the const">
        <p>
          Some people favor the form <code>int const *foo</code> to
          <code>const int* foo</code>.  They argue that this is more
          readable because it's more consistent: it keeps the rule
          that <code>const</code> always follows the object it's
          describing.  However, this consistency argument doesn't
          apply in codebases with few deeply-nested pointer
          expressions since most <code>const</code> expressions have
          only one <code>const</code>, and it applies to the
          underlying value.  In such cases, there's no consistency to
          maintain.
          Putting the <code>const</code> first is arguably more readable,
          since it follows English in putting the "adjective"
          (<code>const</code>) before the "noun" (<code>int</code>).
        </p>
        <p>
          That said, while we encourage putting <code>const</code> first,
          we do not require it.  But be consistent with the code around
          you!
        </p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Integer Types">
    <SUMMARY>
      Of the ANSI C integer types, the only one used is 
      <code>int</code>.  If a program needs a variable of a different
      size, use
      
      a precise-width integer type from
      <code>&lt;stdint.h&gt;</code>, such as <code>int16_t</code>
       (or <code>signed int16</code> when using a CCS compiler). 
      Keep in mind that even if your value won't ever be too large for an
      <code>int</code>, it may be used in intermediate calculations which may
      require a larger type. When in doubt, choose a larger type.
    </SUMMARY>
    <BODY>
      <DEFINITION>
        C does not specify the sizes of its integer types. Typically, for embedded processors
        people assume that <code>short</code> is 8 bits,
        <code>int</code> is 16 bits and <code>long</code> is 32 bits.
      </DEFINITION>
      <PROS>
        Uniformity of declaration.
      </PROS>
      <CONS>
        The sizes of integral types in C can vary based on compiler
        and architecture.
      </CONS>
      <DECISION>
        <p>
          
          <code>&lt;stdint.h&gt;</code> defines
          types like <code>int16_t</code>, <code>uint32_t</code>,
          <code>int32_t</code>, etc.
          You should always use those in preference to
          <code>short</code>, <code>unsigned long long</code> and the
          like, when you need a guarantee on the size of an integer.
          Of the C integer types, only <code>int</code> should be
          used.  When appropriate, you are welcome to use standard
          types like <code>size_t</code> and <code>ptrdiff_t</code>.
        </p>
        <p>
          We use <code>int</code> very often, for integers we know are not
          going to be too big, e.g., loop counters. Use plain old
          <code>int</code> for such things. You should assume that an
          <code>int</code> is
          
          at least 8 bits,
          but don't assume that it has more than 8 bits.
          If you need a 16-bit integer type, use
          <code>int16_t</code> or
          <code>uint16_t</code> (<code>signed int16</code> or <code>int16</code> for CCS).
        </p>
        
        <p>
          For integers we know can be "big", use <code>int32_t</code> (or <code>signed int32</code> with a CCS compiler).
        </p>
        
        <p>
          You should not use the unsigned integer types such as
          <code>uint32_t</code>,
          unless there is a valid reason such as representing a bit pattern
          rather than a number, or you need defined overflow modulo 2^N.
          In particular, do not use unsigned types to say a number will never
          be negative.
        </p>
        
        <p>
          If your code is a container that returns a size, be sure to use
          a type that will accommodate any possible usage of your container.
          When in doubt, use a larger type rather than a smaller type.
        </p>
        <p>
          Use care when converting integer types. Integer conversions and
          promotions can cause non-intuitive behavior.
          
        </p>
      </DECISION>

      <SUBSECTION title="On Unsigned Integers">
        <p>
          Some people, including some textbook authors, recommend
          using unsigned types to represent numbers that are never
          negative.  This is intended as a form of self-documentation.
          However, in C, the advantages of such documentation are
          outweighed by the real bugs it can introduce.  Consider:
        </p>
        <CODE_SNIPPET>
          for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...
        </CODE_SNIPPET>
        <p>
          This code will never terminate!  Sometimes gcc will notice
          this bug and warn you, but often it will not.  Equally bad
          bugs can occur when comparing signed and unsigned
          variables.  Basically, C's type-promotion scheme causes
          unsigned types to behave differently than one might expect.
        </p>
        <p>
          So, document that a variable is non-negative using
          comments.
          Don't use an unsigned type.
        </p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Preprocessor Macros">
    <SUMMARY>
      Be very cautious with macros.  Prefer inline functions, enums,
      and <code>const</code> variables to macros.
    </SUMMARY>
    <BODY>
      <p>
        Macros mean that the code you see is not the same as the code
        the compiler sees.  This can introduce unexpected behavior,
        especially since macros have global scope.
      </p>
      <p>
        Instead of using a macro to inline performance-critical code, use an inline function. Instead of using a macro to store a constant, use a const variable. Instead of using a macro to "abbreviate" a long variable name, use a reference. Instead of using a macro to conditionally compile code ... well, don't do that at all (except, of course, for the #define guards to prevent double inclusion of header files). It makes testing much more difficult.
      </p>
      <p>
        Macros can do things these other techniques cannot, and you do see them in the codebase, especially in the lower-level libraries. And some of their special features (like stringifying, concatenation, and so forth) are not available through the language proper. But before using a macro, consider carefully whether there's a non-macro way to achieve the same result.
      </p>
      <p>
        The following usage pattern will avoid many problems with
        macros; if you use macros, follow it whenever possible:
      </p>
      <ul>
        <li> Don't define macros in a <code>.h</code> file.
             </li>
        <li> <code>#define</code> macros right before you use them,
             and <code>#undef</code> them right after.
             </li>
        <li> Do not just <code>#undef</code> an existing macro before
             replacing it with your own; instead, pick a name that's
             likely to be unique.
             </li>
        <li> Try not to use macros that expand to unbalanced C
             constructs, or at least document that behavior well.
             </li>
        <li> Prefer not using <code>##</code> to generate function/variable
             names.
             </li>
      </ul>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="0 and nullptr/NULL">
  <SUMMARY>
    Use <code>0</code> for integers, <code>0.0</code> for floats,
    <code>NULL</code> for pointers,
    and <code>'\0'</code> for chars.
  </SUMMARY>
  
  </STYLEPOINT>

  <STYLEPOINT title="sizeof">
  <SUMMARY>
    Prefer <code>sizeof(<var>varname</var>)</code> to
    <code>sizeof(<var>type</var>)</code>.
  </SUMMARY>
  <BODY>
    <p>
      Use <code>sizeof(<var>varname</var>)</code>
      when you take the size of a particular variable.
      <code>sizeof(<var>varname</var>)</code> will update
      appropriately if someone changes the variable type
      either now or later.
      You may use <code>sizeof(<var>type</var>)</code>
      for code unrelated to any particular variable,
      such as code that manages an external or internal
      data format where a variable of an appropriate C type
      is not convenient.
    </p>
    <p>
      <CODE_SNIPPET>
        Struct data;
        memset(&amp;data, 0, sizeof(data));
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        memset(&amp;data, 0, sizeof(Struct));
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        if (raw_size &lt; sizeof(int)) 
        {
          printf( "compressed record not big enough for count: ",  raw_size);
          return false;
        }
      </CODE_SNIPPET>
    </p>
  </BODY>
  </STYLEPOINT>

</CATEGORY>

<CATEGORY title="Naming">
  <p>
    The most important consistency rules are those that govern
    naming. The style of a name immediately informs us what sort of
    thing the named entity is: a type, a variable, a function, a
    constant, a macro, etc., without requiring us to search for the
    declaration of that entity. The pattern-matching engine in our
    brains relies a great deal on these naming rules.
    
  </p>
  <p>
    Naming rules are pretty arbitrary, but
    
    we feel that consistency is more important than individual preferences
    in this area, so regardless of whether you find them sensible or not,
    the rules are the rules.
  </p>

  <STYLEPOINT title="General Naming Rules">
    <SUMMARY>
      Function names, variable names, and filenames should be
      descriptive; eschew abbreviation.
    </SUMMARY>
    <BODY>
      <p>
        Give as descriptive a name as possible, within reason. Do
        not worry about saving horizontal space as it is far more
        important to make your code immediately understandable by a
        new reader. Do not use abbreviations that are ambiguous or
        unfamiliar to readers outside your project, and do not
        abbreviate by deleting letters within a word.
      </p>
      <CODE_SNIPPET>
        int price_count_reader;    // No abbreviation.
        int num_errors;            // "num" is a widespread convention.
        int num_dns_connections;   // Most people know what "DNS" stands for.
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        int n;                     // Meaningless.
        int nerr;                  // Ambiguous abbreviation.
        int n_comp_conns;          // Ambiguous abbreviation.
        int wgc_connections;       // Only your group knows what this stands for.
        int pc_reader;             // Lots of things can be abbreviated "pc".
        int cstmr_id;              // Deletes internal letters.
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="File Names">
    <SUMMARY>
      Filenames should be all lowercase with underscores
      (<code>_</code>) between words.
    </SUMMARY>
    <BODY>
      <p>
        Here's an example of an acceptable file name:
      </p>
      <p>
        <code>
          my_useful_module.c<br/>          
        </code>
      </p>
      <p>
        C files should end in <code>.c</code> and header files
        should end in <code>.h</code>.
      </p>
      <p>
        Do not use filenames that already exist
        in <code>/usr/include</code>, such as <code>db.h</code>.
      </p>
      <p>
        In general, make your filenames very specific.  For example,
        use <code>http_server_logs.h</code> rather
        than <code>logs.h</code>.  
      </p>
      <p>
        Inline functions must be in a <code>.h</code> file. If your
        inline functions are very short, they should go directly into your
        <code>.h</code> file. However, if your inline functions
        include a lot of code, they may go into a third file that
        ends in <code>-inl.h</code>.  In a class with a lot of inline
        code, your class could have three files:
      </p>
      <CODE_SNIPPET>
        url_table.h      // The module interface
        url_table.c      // The module code
        url_table-inl.h  // Inline functions that include lots of code.
      </CODE_SNIPPET>
      <p>
        See also the section <a href="#The_-inl.h_Files">-inl.h Files</a>
      </p>      
      <SUBSECTION title="State machine files">
        <p>
          State machine <code>.c</code> and <code>.h</code> files should be given the
          prefix <code>sm_</code> for example:
        </p>
        <CODE_SNIPPET>
          sm_master.c
          sm_master.h
        </CODE_SNIPPET>        
      </SUBSECTION>      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Type Names">
    <SUMMARY>
      Type names start with a capital letter and have a capital
      letter for each new word, with no underscores:
      <code>MyExcitingStruct</code>, <code>MyExcitingEnum</code>.
    </SUMMARY>
    <BODY>
      <p>
        The names of all types — structs, typedefs, and enums
        — have the same naming convention.  Type names should start
        with a capital letter and have a capital letter for each new
        word.  No underscores.
      </p>      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Variable Names">
    <SUMMARY>
      Variable names are all lowercase, with underscores between
      words.  Module-level variables have trailing underscores. For
      instance: <code>my_exciting_local_variable</code>,
      <code>my_exciting_module_variable_</code>.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Common Variable names">
        <p>
          For example:
        </p>
        <CODE_SNIPPET>
          int epoch_number;  // OK - uses underscore.
          int epochnumber;   // OK - all lowercase.
        </CODE_SNIPPET>
        <BAD_CODE_SNIPPET>
          int epochNumber;   // Bad - mixed case.
        </BAD_CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Module Variables">
        <p>
          Module variables are lowercase with optional underscores like regular variable names, but always end with a trailing underscore.
        </p>
        <CODE_SNIPPET>
          int epoch_number_;  // OK - underscore at end.
          string epochnumber_;   // OK.
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Struct Variables">
        <p>
          Data members in structs should be named like regular
          variables without the trailing underscores that data members
          in classes have.
        </p>
        <CODE_SNIPPET>
          struct UrlTableProperties
          {
            string name;
            int num_entries;
          }
        </CODE_SNIPPET>
        
      </SUBSECTION>

     
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Constant Names">
    <SUMMARY>
      Use a <code>k</code> followed by mixed case:
      <code>kDaysInAWeek</code>.
    </SUMMARY>
    <BODY>
      <p>
        All compile-time constants, whether they are declared locally,
        globally, or as part of a class, follow a slightly different
        naming convention from other variables. Use a <code>k</code>
        followed by words with uppercase first letters:
      </p>
      <CODE_SNIPPET>
        const int kDaysInAWeek = 7;
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Names">
    <SUMMARY>
      Function names have mixed case: <code>MyExcitingFunction()</code>
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Regular Functions">
        <p>
          Functions should start with a capital letter and have a
          capital letter for each new word. No underscores.
        </p>
        <p>
          If your function crashes upon an error, you should append OrDie to
          the function name. This only applies to functions which could be
          used by production code and to errors that are reasonably
          likely to occur during normal operation.
        </p>
        <CODE_SNIPPET>
          AddTableEntry()
          DeleteUrl()
          OpenFileOrDie()
        </CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Enumerator Names">
    <SUMMARY>
      Enumerators should be named <i>either</i> like
      <A HREF="#Constant_Names">constants</A> or like
      <A HREF="#Macro_Names">macros</A>: either <code>kEnumName</code>
      or <code>ENUM_NAME</code>.
    </SUMMARY>
    <BODY>
      <p>
        Preferably, the individual enumerators should be named like
        <A HREF="#Constant_Names">constants</A>.  However, it is also
        acceptable to name them like <A HREF="#Macro_Names">macros</A>.    The enumeration name,
        <code>UrlTableErrors</code> (and
        <code>AlternateUrlTableErrors</code>), is a type, and
        therefore mixed case.
      </p>
      <CODE_SNIPPET>
        enum UrlTableErrors 
        {
          kOK = 0,
          kErrorOutOfMemory,
          kErrorMalformedInput,
        };
        enum AlternateUrlTableErrors 
        {
          OK = 0,
          OUT_OF_MEMORY = 1,
          MALFORMED_INPUT = 2,
        };
      </CODE_SNIPPET>
      <p>
        Until January 2009, the style was to name enum values like
        <A HREF="#Macro_Names">macros</A>.  This caused problems with
        name collisions between enum values and macros.  Hence, the
        change to prefer constant-style naming was put in place.  New
        code should prefer constant-style naming if possible.
        However, there is no reason to change old code to use
        constant-style names, unless the old names are actually
        causing a compile-time problem.
      </p>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Macro Names">
    <SUMMARY>
      You're not really going to <A HREF="#Preprocessor_Macros">define
      a macro</A>, are you?  If you do, they're like this:
      <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.
    </SUMMARY>
    <BODY>
      <p>
        Please see the <a href="#Preprocessor_Macros">description of
        macros</a>; in general macros should <em>not</em> be used.
        However, if they are absolutely needed, then they should be
        named with all capitals and underscores.
      </p>
      <CODE_SNIPPET>
        #define ROUND(x) ...
        #define PI_ROUNDED 3.0
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Exceptions to Naming Rules">
    <SUMMARY>
      If you are naming something that is analogous to an existing C
     entity then you can follow the existing naming convention
      scheme.
    </SUMMARY>
    <BODY>
      <p>
        <dl>
          <dt> <code>bigopen()</code> </dt>
          <dd>   function name, follows form of <code>open()</code> </dd>
          <dt> <code>uint</code> </dt>
          <dd>   <code>typedef</code> </dd>
          <dt> <code>bigpos</code> </dt>
          <dd>   <code>struct</code> or <code>class</code>, follows form of
                 <code>pos</code> </dd>          
          <dt> <code>LONGLONG_MAX</code> </dt>
          <dd>   a constant, as in <code>INT_MAX</code> </dd>
        </dl>
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Comments">
  <p>
    Though a pain to write, comments are absolutely vital to keeping our
    code readable.  The following rules describe what you should
    comment and where.  But remember: while comments are very
    important, the best code is self-documenting.  Giving sensible
    names to types and variables is much better than using obscure
    names that you must then explain through comments.
  </p>
  <p>
    When writing your comments, write for your audience: the next
    
    contributor
    who will need to understand your code.  Be generous — the next
    one may be you!
  </p>

  <STYLEPOINT title="Comment Style">
    <SUMMARY>
      Use the <code>//</code> syntax. Do not use the <code>/* */</code> syntax.
    </SUMMARY>
    <BODY>
      <p>
        To avoid clutter, don't make elaborate ASCII art. Just write text comments.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="File Comments">
    <SUMMARY>
      Start each file with copyright boilerplate, followed by a description of its contents.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Legal Notice and Author Line">
        
        <p>
          Every file should contain this boilerplate: 
        <CODE_SNIPPET>
          // Copyright (c) &lt;year&gt; Velocitek Inc. All rights reserved.
          // Author(s): &lt;first contributor&gt;, &lt;second contributor&gt;
          //
          // Please follow the Velocitek C Style Guide when maintaining this code.
          // http://www.velocitek.com/style-guide/c_style_guide.xml
        </CODE_SNIPPET>
        </p>
        <p>
          If you make changes to a file to the extent that the original author wouldn't recognize it,
          consider removing the original author's name.
        </p>        
        <p>
          All state machine <code>.c</code> files should contain an additional line in the boilerplate:
        </p>
        <CODE_SNIPPET>
          // Copyright (c) 2014 Velocitek Inc. All rights reserved.
          // Author(s): &lt;first contributor&gt;, &lt;second contributor&gt;
          //
          // Hierarchical State Machine Template by Ed Carryer, Stanford University
          //
          // Please follow the Velocitek C Style Guide when maintaining this code.
          // http://www.velocitek.com/style-guide/c_style_guide.xml
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="File Contents">
        <p>
          Every file should have a comment at the top describing its contents.
        </p>
        <p>
          Generally a <code>.h</code> file will describe the public
          functions declared inthe file with an overview of what they
          are for and how they are used. A <code>.c</code> file
          should contain more information about implementation details
          or discussions of tricky algorithms. If you feel the
          implementation details or a discussion of the algorithms
          would be useful for someone reading the <code>.h</code>,
          feel free to put it there instead, but mention in the
          <code>.c</code> that the documentation is in the
          <code>.h</code> file.
        </p>
        <p>
          Do not duplicate comments in both the <code>.h</code> and
          the <code>.c</code>. Duplicated comments diverge.
        </p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Section Dividers">
    <SUMMARY>
      Use standard section divider when you want to visually breakup code into different sections.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Standard Section Divider Format">
        
        <p>
          Every section divider should look like these examples: 
        <CODE_SNIPPET>
          // Section Title ---------------------------------------------------------------
          ... code

          // Module Constants ------------------------------------------------------------
          ... code

          // Module Functions ------------------------------------------------------------
          ... code

          // Module Variables ------------------------------------------------------------
          ... code

          // Module Code -----------------------------------------------------------------
          ... code
        </CODE_SNIPPET>
        </p>
        <p>
          There is one space after the section title and then enough dashes to make the whole
          divider 80 characters long. The number of dashes varies, depending on the length of the section title,
          to make the divider exactly 80 characters long.
        </p>
        <p>
          The section titles are capitalized using title case; the first letter of every major word is capitalized.
          Minor words such as conjunctions, articles and short prepositions are not capitalized. 
          The first letter of the first word is always capitalized, and words of four letters or more are always capitalized.
        </p>
      </SUBSECTION>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Comments">
    <SUMMARY>
      Declaration comments describe use of the function; comments at
      the definition of a function describe operation.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Function Declarations">
        <p>
          Every function declaration should have comments immediately
          preceding it that describe what the function does and how to
          use it.  These comments should be descriptive ("Opens the
          file") rather than imperative ("Open the file"); the comment
          describes the function, it does not tell the function what
          to do.  In general, these comments do not describe how the
          function performs its task.  Instead, that should be left to
          comments in the function definition.
        </p>
        <p>
          Types of things to mention in comments at the function
          declaration:
        </p>
        <ul>
          <li> What the inputs and outputs are.
               </li>
          <li> For module public functions:  whether the module
               remembers function arguments beyond the
               duration of the function call.
               </li>
          <li> If the function allocates memory that the caller
               must free.
               </li>
          <li> Whether any of the arguments can be a null pointer.
               </li>
          <li> If there are any performance implications of how a
               function is used.
               </li>
          
        </ul>
        
        <p>
          However, do not be unnecessarily verbose or state the
          completely obvious.  Notice below that it is not necessary
          to say "returns false otherwise" because this is implied.
        </p>
        <CODE_SNIPPET>
          // Returns true if the table cannot hold any more entries.
          bool IsTableFull();
        </CODE_SNIPPET>
        
      </SUBSECTION>

      <SUBSECTION title="Function Definitions">
        <p>
          If there is anything tricky about how a function does its
          job, the function definition should have an explanatory
          comment. For example, in the definition comment you might
          describe any coding tricks you use, give an overview of the
          steps you go through, or explain why you chose to implement
          the function in the way you did rather than using a viable
          alternative. 
        </p>
        <p>
          Note you should <em>not</em> just repeat the comments given
          with the function declaration, in the <code>.h</code> file or
          wherever.  It's okay to recapitulate briefly what the function
          does, but the focus of the comments should be on how it does it.
        </p>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Variable Comments">
    <SUMMARY>
      In general the actual name of the variable should be descriptive
      enough to give a good idea of what the variable is used for.  In
      certain cases, more comments are required.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Module Variables">
        <p>
          Each module variable should have a comment describing what it is used for. If the variable can take sentinel values with special meanings, such as a null pointer or -1, document this. For example:
        </p>
        <CODE_SNIPPET>          
          // Keeps track of the total number of entries in the table.
          // Used to ensure we do not go over the limit. -1 means
          // that we don't yet know how many entries the table has.
          int num_total_entries_;
        </CODE_SNIPPET>
      </SUBSECTION>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Implementation Comments">
    <SUMMARY>
      In your implementation you should have comments in tricky,
      non-obvious, interesting, or important parts of your code.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="Class Data Members">
        <p>
          Tricky or complicated code blocks should have comments
          before them. Example:
        </p>
        <CODE_SNIPPET>
          // Divide result by two, taking into account that x
          // contains the carry from the add.
          for (int i = 0; i &lt; result-&gt;size(); i++) 
          {
            x = (x &lt;&lt; 8) + (*result)[i];
            (*result)[i] = x &gt;&gt; 1;
            x &amp;= 1;
          }
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="Line Comments">
        <p>
          Also, lines that are non-obvious should get a comment at the
          end of the line. These end-of-line comments should be
          separated from the code by 2 spaces.  Example:
        </p>
        <CODE_SNIPPET>
          // If we have enough memory, mmap the data portion too.
          mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
          if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
            return;  // Error already logged.
        </CODE_SNIPPET>
        <p>
          Note that there are both comments that describe what the
          code is doing, and comments that mention that an error has
          already been logged when the function returns.
        </p>
        <p>
          If you have several comments on subsequent lines, it can
          often be more readable to line them up:
        </p>
        <CODE_SNIPPET>
          DoSomething();                  // Comment here so the comments line up.
          DoSomethingElseThatIsLonger();  // Comment here so there are two spaces between
                                          // the code and the comment.
          { // One space before comment when opening a new scope is allowed,
            // thus the comment lines up with the following comments and code.
            DoSomethingElse();  // Two spaces before line comments normally.
          }
          DoSomething(); /* For trailing block comments, one space is fine. */
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="nullptr/NULL, true/false, 1, 2, 3...">
        <p>
          When you pass in a null pointer, boolean, or literal integer
          values to functions, you should consider adding a comment about
          what they are, or make your code self-documenting by using
          constants. For example, compare:
        </p>
        <BAD_CODE_SNIPPET>
          bool success = CalculateSomething(interesting_value,
                                            10,
                                            false,
                                            NULL);  // What are these arguments??
        </BAD_CODE_SNIPPET>
        <p>
          versus:
        </p>
        <CODE_SNIPPET>
          bool success = CalculateSomething(interesting_value,
                                            10,     // Default base value.
                                            false,  // Not the first time we're calling this.
                                            NULL);  // No callback.
        </CODE_SNIPPET>
        <p>
          Or alternatively, constants or self-describing variables:
        </p>
        <CODE_SNIPPET>
          const int kDefaultBaseValue = 10;
          const bool kFirstTimeCalling = false;
          Callback *null_callback = NULL;
          bool success = CalculateSomething(interesting_value,
                                            kDefaultBaseValue,
                                            kFirstTimeCalling,
                                            null_callback);
        </CODE_SNIPPET>
      </SUBSECTION>

      <SUBSECTION title="Don'ts">
        <p>
          Note that you should <em>never</em> describe the code
          itself. Assume that the person reading the code knows C
          better than you do, even though he or she does not know what
          you are trying to do:
        </p>
        <BAD_CODE_SNIPPET>
           // Now go through the b array and make sure that if i occurs,
           // the next element is i+1.
           ...        // Geez.  What a useless comment.
        </BAD_CODE_SNIPPET>
      </SUBSECTION>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Punctuation, Spelling and Grammar">
    <SUMMARY>
      Pay attention to punctuation, spelling, and grammar; it is
      easier to read well-written comments than badly written ones.
    </SUMMARY>
    <BODY>
      <p>
        Comments should be as readable as narrative text, with proper
        capitalization and punctuation. In many cases, complete sentences are
        more readable than sentence fragments. Shorter comments, such as
        comments at the end of a line of code, can sometimes be less formal, but
        you should be consistent with your style.
      </p>
      <p>
        Although it can be frustrating to have a code reviewer point
        out that you are using a comma when you should be using a
        semicolon, it is very important that source code maintain a
        high level of clarity and readability.  Proper punctuation,
        spelling, and grammar help with that goal.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="TODO Comments">
    <SUMMARY>
      Use <code>TODO</code> comments for code that is temporary, a
      short-term solution, or good-enough but not perfect.
    </SUMMARY>
    <BODY>
      <p>
        <code>TODO</code>s should include the string <code>TODO</code> in
        all caps, followed by the
        
        name, e-mail address, or other
        identifier
        of the person who can best provide context about the problem
        referenced by the <code>TODO</code>.  A colon is optional.  The main
        purpose is to have a consistent <code>TODO</code> format that can be
        searched to find the person who can provide more details upon request.
        A <code>TODO</code> is not a commitment that the person referenced
        will fix the problem.  Thus when you create a <code>TODO</code>, it is
        almost always your
        
        name
        that is given.
      </p>
      
      <CODE_SNIPPET>
        // TODO(kl@gmail.com): Use a "*" here for concatenation operator.
        // TODO(Zeke) change this to use relations.
      </CODE_SNIPPET>
      <p>
        If your <code>TODO</code> is of the form "At a future date do
        something" make sure that you either include a very specific
        date ("Fix by November 2005") or a very specific event
        ("Remove this code when all clients can handle XML responses.").
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Deprecation Comments">
    <SUMMARY>
      Mark deprecated interface points with <code>DEPRECATED</code> comments.
    </SUMMARY>
    <BODY>
      <p>
      You can mark an interface as deprecated by writing a comment containing
      the word <code>DEPRECATED</code> in all caps.  The comment goes either
      before the declaration of the interface or on the same line as the
      declaration.
      </p>
      
      <p>
      After the word <code>DEPRECATED</code>, write your name, e-mail address,
      or other identifier in parentheses.
      </p>
      <p>
      A deprecation comment must include simple, clear directions for people to
      fix their callsites.  In C, you can implement a deprecated function as
      an inline function that calls the new interface point.
      </p>
      <p>
      Marking an interface point <code>DEPRECATED</code> will not magically
      cause any callsites to change.  If you want people to actually stop using
      the deprecated facility, you will have to fix the callsites yourself or
      recruit a crew to help you.
      </p>
      <p>
      New code should not contain calls to deprecated interface points.  Use
      the new interface point instead.  If you cannot understand the
      directions, find the person who created the deprecation and ask them for
      help using the new interface point.
      </p>
      
    </BODY>
  </STYLEPOINT>

</CATEGORY>

<CATEGORY title="Formatting">
  <p>
    Coding style and formatting are pretty arbitrary, but a
    
    project
    is much easier to follow if everyone uses the same style. Individuals
    may not agree with every aspect of the formatting rules, and some of
    the rules may take some getting used to, but it is important that all
    
    project contributors
    follow the style rules so that
    
    they
    can all read and understand everyone's code easily.
  </p>
  
  <p>
     <A HREF="http://astyle.sourceforge.net/">Artistic Style</A> is a great utility for automatically formatting C code. 
     Use this Artistic Style <A HREF="http://www.velocitek.com/style-guide/astyle_options.txt">options file</A> 
     to format your code in a way that is consistent with this style guide.
  </p>

  <STYLEPOINT title="Line Length">
    <SUMMARY>
      Each line of text in your code should be at most 80 characters
      long.
    </SUMMARY>
    <BODY>
      
      <p>
        We recognize that this rule is controversial, but so much existing
        code already adheres to it, and we feel that consistency is
        important.
      </p>
      <PROS>
          Those who favor
          
          this rule argue
          that it is rude to force them to resize their windows and there
          is no need for anything longer.  Some folks are used to having
          several code windows side-by-side, and thus don't have room to
          widen their windows in any case.  People set up their work
          environment assuming a particular maximum window width, and 80
          columns has been the traditional standard.  Why change it?
      </PROS>
      <CONS>
          Proponents of change argue that a wider line can make code
          more readable.  The 80-column limit is an hidebound
          throwback to 1960s mainframes;
          
          modern equipment has
          wide screens that can easily show longer lines.
      </CONS>
      <DECISION>
        <p>
          
          80 characters is the maximum.
        </p>
        <p>
          Exception: if a comment line contains an example command or
          a literal URL longer than 80 characters, that line may be
          longer than 80 characters for ease of cut and paste.
        </p>
        <p>
          Exception: an <code>#include</code> statement with a long
          path may exceed 80 columns.  Try to avoid situations where this
          becomes necessary.
        </p>
        <p>
          Exception:  you needn't be concerned about
          <a href="#The__define_Guard">header guards</a>
          that exceed the maximum length.
          
        </p>
      </DECISION>
    </BODY>
  </STYLEPOINT>


  <STYLEPOINT title="Spaces vs. Tabs">
    <SUMMARY>
      Use only spaces, and indent 2 spaces at a time.
    </SUMMARY>
    <BODY>
      <p>
        We use spaces for indentation. Do not use tabs in your code.
        You should set your editor to emit spaces when you hit the tab
        key.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Declarations and Definitions">
    <SUMMARY>
      Return type on the same line as function name, parameters on the
      same line if they fit.
    </SUMMARY>
    <BODY>
      <p>
        Functions look like this:
      </p>
      <CODE_SNIPPET>
        ReturnType FunctionName(Type par_name1, Type par_name2) 
        {
          DoSomething();
          ...
        }
      </CODE_SNIPPET>
      <p>
        If you have too much text to fit on one line:
      </p>
      <CODE_SNIPPET>
        ReturnType ReallyLongFunctionName(Type par_name1, Type par_name2,
                                                     Type par_name3) 
        {
          DoSomething();
          ...
        }
      </CODE_SNIPPET>
      <p>
        or if you cannot fit even the first parameter:
      </p>
      <CODE_SNIPPET>
        ReturnType ReallyReallyReallyLongFunctionName(
            Type par_name1,  // 4 space indent
            Type par_name2,
            Type par_name3) 
        {
          DoSomething();  // 2 space indent
          ...
        }
      </CODE_SNIPPET>
      <p>
        Some points to note:
      </p>
      <ul>
        <li> If you cannot fit the return type and the function name on a single
             line, break between them.
             </li>
        <li> If you break after the return type of a function definition, do not
             indent.
             </li>
        <li> The open parenthesis is always on the same line as the
             function name.
             </li>
        <li> There is never a space between the function name and the
             open parenthesis.
             </li>
        <li> There is never a space between the parentheses and the
             parameters.
             </li>
        <li> The open curly brace is always on a new line.             
             </li>
        <li> The close curly brace is on the last line by itself.
             or on the same line as the
             open curly brace.
             </li>        
        <li> All parameters should be named, with identical names in the
             declaration and implementation.
             </li>
        <li> All parameters should be aligned if possible.
             </li>
        <li> Default indentation is 2 spaces.
             </li>
        <li> Wrapped parameters have a 4 space indent.
             </li>
      </ul>
      
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Function Calls">
    <SUMMARY>
      On one line if it fits; otherwise, wrap arguments at the
      parenthesis.
    </SUMMARY>
    <BODY>
      <p>
        Function calls have the following format:
      </p>
      <CODE_SNIPPET>
        bool retval = DoSomething(argument1, argument2, argument3);
      </CODE_SNIPPET>
      <p>
        If the arguments do not all fit on one line, they should be
        broken up onto multiple lines, with each subsequent line
        aligned with the first argument.  Do not add spaces after the
        open paren or before the close paren:
      </p>
      <CODE_SNIPPET>
        bool retval = DoSomething(averyveryveryverylongargument1,
                                  argument2, argument3);
      </CODE_SNIPPET>
      <p>
        If the function has many arguments, consider having one per
        line if this makes the code more readable:
      </p>
      <CODE_SNIPPET>
        bool retval = DoSomething(argument1,
                                  argument2,
                                  argument3,
                                  argument4);
      </CODE_SNIPPET>
      <p>
        Arguments may optionally all be placed on subsequent lines, with one
        line per argument:
      </p>
      <CODE_SNIPPET>
        if (...) 
        {
          ...
          ...
          if (...) 
          {
            DoSomething(
                argument1,  // 4 space indent
                argument2,
                argument3,
                argument4);
          }
      </CODE_SNIPPET>
      <p>
        In particular, this should be done if the function signature is so long
        that it cannot fit within the maximum <a href="#Line_Length">line
        length</a>.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Braced Initializer Lists">
    <SUMMARY>
      Format a braced list exactly like you would format a function call in its
      place.
    </SUMMARY>
    <BODY>
      <p>
        If the braced list follows a name (e.g. a type or variable name),
        format as if the <code>{}</code> were the parentheses of a function call
        with that name. If there is no name, assume a zero-length name.
      </p>
      <CODE_SNIPPET>
        // Examples of braced init list on a single line.
        return {foo, bar};
        functioncall({foo, bar});
        

        // When you have to wrap.
        SomeFunction(
            {"assume a zero-length name before {"},
            some_other_function_parameter);
        SomeType variable{
            some, other, values,
            {"assume a zero-length name before {"},
            SomeOtherType{
                "Very long string requiring the surrounding breaks.",
                some, other values},
            SomeOtherType{"Slightly shorter string",
                          some, other, values}};
        SomeType variable{
            "This is too long to fit all in one line"};
        MyType m = {  // Here, you could also break before {.
            superlongvariablename1,
            superlongvariablename2,
            {short, interior, list},
            {interiorwrappinglist,
             interiorwrappinglist2}};
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Conditionals">
    <SUMMARY>
      Do not use spaces inside parentheses.  The <code>else</code>
      keyword belongs on a new line.
    </SUMMARY>
    <BODY>
      
      <CODE_SNIPPET>
        if (condition)  // no spaces inside parentheses
        {      
          ...  // 2 space indent.
        } 
        else if (...)  // The else goes on a new line.
        {  
          ...
        } 
        else 
        {
          ...
        }
      </CODE_SNIPPET>
      
      <p>
        Note that in all cases you must have a space between the
        <code>if</code> and the open parenthesis.  The opening curly brace must
        appear on a new line.
      </p>
      <BAD_CODE_SNIPPET>
        if(condition)     // Bad - space missing after IF.
        if (condition){   // Bad - { Appears on the same line as the condition.
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        if (condition) // Good - proper space after IF and { occurs on a new line.
        {  
      </CODE_SNIPPET>
      <p>
        Short conditional statements may be written on one line if
        this enhances readability.  You may use this only when the
        line is brief and the statement does not use the
        <code>else</code> clause.
      </p>
      <CODE_SNIPPET>
        if (x == kFoo) return new Foo();
        if (x == kBar) return new Bar();
      </CODE_SNIPPET>
      <p>
        This is not allowed when the if statement has an
        <code>else</code>:
      </p>
      <BAD_CODE_SNIPPET>
        // Not allowed - IF statement on one line when there is an ELSE clause
        if (x) DoThis();
        else DoThat();
      </BAD_CODE_SNIPPET>
      <p>
        In general, curly braces are not required for single-line
        statements, but they are allowed if you like them;
        conditional or loop statements with complex conditions or
        statements may be more readable with curly braces. Some
        
        projects
        require that an <CODE>if</CODE> must always always have an
        accompanying brace.
      </p>
      <CODE_SNIPPET>
        if (condition)
          DoSomething();  // 2 space indent.

        if (condition) 
        {
          DoSomething();  // 2 space indent.
        }
      </CODE_SNIPPET>
      <p>
        However, if one part of an <code>if</code>-<code>else</code>
        statement uses curly braces, the other part must too:
      </p>
      <BAD_CODE_SNIPPET>
        // Not allowed - curly on IF but not ELSE
        if (condition) 
        {
          foo;
        } 
        else
          bar;

        // Not allowed - curly on ELSE but not IF
        if (condition)
          foo;
        else 
        {
          bar;
        }
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        // Curly braces around both IF and ELSE required because
        // one of the clauses used braces.
        if (condition) 
        {
          foo;
        } 
        else 
        {
          bar;
        }
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Loops and Switch Statements">
    <SUMMARY>
      Switch statements may use braces for blocks. Annotate non-trivial
      fall-through between cases. Empty loop bodies should use <code>{}</code>
      or <code>continue</code>.
    </SUMMARY>
    <BODY>
      <p>
        <code>case</code> blocks in <code>switch</code> statements can have
        curly braces or not, depending on your preference.  If you do
        include curly braces they should be placed as shown below.
      </p>
      <p>
        If not conditional on an enumerated value, switch statements
        should always have a <code>default</code> case (in the case of
        an enumerated value, the compiler will warn you if any values
        are not handled). 
      </p>
      
     
      
      
      <p>
        Empty loop bodies should use <code>{}</code> or
        <code>continue</code>, but not a single semicolon.
      </p>
      <CODE_SNIPPET>
        while (condition) 
        {
          // Repeat test until it returns false.
        }
        for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Good - empty body.
        while (condition) continue;  // Good - continue indicates no logic.
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        while (condition);  // Bad - looks like part of do/while loop.
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Pointer and Reference Expressions">
    <SUMMARY>
      No spaces around period or arrow.  Pointer operators do not have
      trailing spaces.
    </SUMMARY>
    <BODY>
      <p>
        The following are examples of correctly-formatted pointer and
        reference expressions:
      </p>
      <CODE_SNIPPET>
        x = *p;
        p = &amp;x;
        x = r.y;
        x = r-&gt;y;
      </CODE_SNIPPET>
      <p>
        Note that:
      </p>
      <ul>
        <li> There are no spaces around the period or arrow when
             accessing a member.
             </li>
        <li> Pointer operators have no space after the <code>*</code> or
             <code>&amp;</code>.
             </li>
      </ul>
      <p>
        When declaring a pointer variable or argument, you may place
        the asterisk adjacent to either the type or to the variable
        name:
      </p>
      <CODE_SNIPPET>
        // These are fine, space preceding.
        char *c;
        const string &amp;str;

        // These are fine, space following.
        char* c;    // but remember to do "char* c, *d, *e, ...;"!
        const string&amp; str;
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        char * c;  // Bad - spaces on both sides of *
        const string &amp; str;  // Bad - spaces on both sides of &amp;
      </BAD_CODE_SNIPPET>
      <p>
        You should do this consistently within a single
        file,
        so, when modifying an existing file, use the style in that
        file.
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Boolean Expressions">
    <SUMMARY>
      When you have a boolean expression that is longer than the <a href="#Line_Length">standard line length</a>, be consistent in
      how you break up the lines.
    </SUMMARY>
    <BODY>
      <p>
        In this example, the logical AND operator is always at the end
        of the lines:
      </p>
      <CODE_SNIPPET>
        if (this_one_thing &gt; this_other_thing &amp;&amp;
            a_third_thing == a_fourth_thing &amp;&amp;
            yet_another &amp;&amp; last_one) 
        {
          ...
        }
      </CODE_SNIPPET>
      <p>
        Note that when the code wraps in this example, both of
        the <code>&amp;&amp;</code> logical AND operators are at the
        end of the line.  This is more common in Google code, though
        wrapping all operators at the beginning of the line is also
        allowed.  Feel free to insert extra parentheses judiciously
        because they can be very helpful in increasing readability
        when used appropriately.  
      </p>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Return Values">
    <SUMMARY>
      Do not needlessly surround the <code>return</code> expression with
      parentheses.
    </SUMMARY>
    <BODY>
      <p>
        Use parentheses in <code>return expr;</code> only where you would use
        them in <code>x = expr;</code>.
      </p>
      <CODE_SNIPPET>
        return result;                  // No parentheses in the simple case.
        return (some_long_condition &amp;&amp;  // Parentheses ok to make a complex
                another_condition);     //     expression more readable.
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        return (value);                // You wouldn't write var = (value);
        return(result);                // return is not a function!
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  
  <STYLEPOINT title="Preprocessor Directives">
    <SUMMARY>
      The hash mark that starts a preprocessor directive should
      always be at the beginning of the line.
    </SUMMARY>
    <BODY>
      <p>
        Even when preprocessor directives are within the body of
        indented code, the directives should start at the beginning of
        the line.
      </p>
      <CODE_SNIPPET>
        // Good - directives at beginning of line
          if (lopsided_score) 
          {
        #if DISASTER_PENDING      // Correct -- Starts at beginning of line
            DropEverything();
        # if NOTIFY               // OK but not required -- Spaces after #
            NotifyClient();
        # endif
        #endif
            BackToNormal();
          }
      </CODE_SNIPPET>
      <BAD_CODE_SNIPPET>
        // Bad - indented directives
          if (lopsided_score) 
          {
            #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
            DropEverything();
            #endif                // Wrong!  Do not indent "#endif"
            BackToNormal();
          }
      </BAD_CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>

  <STYLEPOINT title="Horizontal Whitespace">
    <SUMMARY>
      Use of horizontal whitespace depends on location.  Never put trailing
      whitespace at the end of a line.
    </SUMMARY>
    <BODY>
      <SUBSECTION title="General">
        <CODE_SNIPPET>
        void f(bool b)
        {  
          ...
        int i = 0;        // Semicolons usually have no space before them.
        int x[] = { 0 };  // Spaces inside braces for braced-init-list are
        int x[] = {0};    // optional.  If you use them, put them on both sides!
        
        </CODE_SNIPPET>
        <p>
          Adding trailing whitespace can cause extra work for others editing
          the same file, when they merge, as can removing existing trailing
          whitespace.  So:  Don't introduce trailing whitespace.  Remove it
          if you're already changing that line, or do it in a separate
          clean-up
          
          operation (preferably when no-one else
          is working on the file).
        </p>
      </SUBSECTION>
      <SUBSECTION title="Loops and Conditionals">
        <CODE_SNIPPET>
        if (b)            // Space after the keyword in conditions and loops. 
        {          
        } 
        else 
        {          
        }
        while (test) {}   // There is usually no space inside parentheses.
        switch (i) 
        {
          for (int i = 0; i &lt; 5; ++i) 
          
        for ( ; i &lt; 5 ; ++i)    // For loops always have a space after the
        {                          // semicolon, and may have a space before the
          ...                      // semicolon.
                                   
        
        switch (i) 
        {
          case 1:         // No space before colon in a switch case.
            ...
          case 2: break;  // Use a space after a colon if there's code after it.
        </CODE_SNIPPET>
      </SUBSECTION>
      <SUBSECTION title="Operators">
        <CODE_SNIPPET>
        x = 0;              // Assignment operators always have spaces around
                            // them.
        x = -5;             // No spaces separating unary operators and their
        ++x;                // arguments.
        if (x &amp;&amp; !y)
          ...
        v = w * x + y / z;  // Binary operators usually have spaces around them,
        v = w*x + y/z;      // but it's okay to remove spaces around factors.
        v = w * (x + z);    // Parentheses should have no spaces inside them.
        </CODE_SNIPPET>
      </SUBSECTION>
      
    </BODY>
  </STYLEPOINT>


  <STYLEPOINT title="Vertical Whitespace">
    <SUMMARY>
      Minimize use of vertical whitespace.
    </SUMMARY>
    <BODY>
      <p>
        This is more a principle than a rule: don't use blank lines
        when you don't have to.  In particular, don't put more than
        one or two blank lines between functions, resist starting
        functions with a blank line, don't end functions with a blank
        line, and be discriminating with your use of blank lines
        inside functions.
      </p>
      <p>
        The basic principle is: The more code that fits on one screen,
        the easier it is to follow and understand the control flow of
        the program.  Of course, readability can suffer from code
        being too dense as well as too spread out, so use your
        judgement.  But in general, minimize use of vertical
        whitespace.
      </p>
      <p>
        Some rules of thumb to help when blank lines may be useful:
      </p>
      <ul>
        <li> Blank lines at the beginning or end of a function very
             rarely help readability.
             </li>
        <li> Blank lines inside a chain of if-else blocks may well
             help readability.
             </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<CATEGORY title="Exceptions to the Rules">
  <p>
    The coding conventions described above are mandatory.  However,
    like all good rules, these sometimes have exceptions, which we
    discuss here.
  </p>

  

  <STYLEPOINT title="Existing Non-conformant Code">
    <SUMMARY>
      You may diverge from the rules when dealing with code that does not
      conform to this style guide.
    </SUMMARY>
    <BODY>
      <p>
        If you find yourself modifying code that was written to
        specifications other than those presented by this guide, you may
        have to diverge from these rules in order to stay consistent with
        the local conventions in that code.  If you are in doubt about
        how to do this, ask the original author or the person currently
        responsible for the code.  Remember that <em>consistency</em>
        includes local consistency, too.
      </p>
    </BODY>
  </STYLEPOINT>

  

</CATEGORY>

<PARTING_WORDS>
  <p>
    Use common sense and <em>BE CONSISTENT</em>.
  </p>
  
  <p>
    The point of having style guidelines is to have a common
    vocabulary of coding so people can concentrate on what you are
    saying, rather than on how you are saying it.  We present
    global style rules here so people know the vocabulary. But
    local style is also important.  If code you add to a file
    looks drastically different from the existing code around it,
    the discontinuity throws readers out of their rhythm when they
    go to read it. Try to avoid this.
  </p>
  
  <p>
    OK, enough writing about writing code; the code itself is much
    more interesting. Have fun!
  </p>
</PARTING_WORDS>

<HR/>

<p align="right">
Revision 0.1
</p>


</GUIDE>
